const encoder = new TextEncoder("utf-8");

const KEY_LENGTH = 32; // AES-GCM keys must be 128, 192, or 256 bits
const IV_LENGTH = 16;
const SALT_LENGTH = 16;

const PBKDF2_PARAMS = {
  name: "PBKDF2",
  hash: "SHA-512",
  iterations: 100,
};

const deriveKey = async (password, salt) => {
  // Turn the string into a TypedArray so we can use it in the crypto library
  const passwordBuffer = encoder.encode(password);

  // Import the password as a PBKDF2 buffer and allow it to be used for deriving
  // additional bits. This imported key is an interim step.
  const imported = await crypto.subtle.importKey(
    "raw",
    passwordBuffer,
    "PBKDF2",
    false,
    ["deriveBits"]
  );

  // Now derive bits using PBKDF2 with the provided password and salt. We want
  // to derive enough bytes to fill our key and initialization vector (IV), so
  // add those two lengths together and multiply by 8, since this function
  // derives bits, not bytes.
  const parts = await crypto.subtle.deriveBits(
    {
      ...PBKDF2_PARAMS,
      salt,
    },
    imported,
    (KEY_LENGTH + IV_LENGTH) * 8
  );

  // Now we split it on the key and IV lengths to get the two pieces.
  const rawKey = parts.slice(0, KEY_LENGTH);
  const iv = new Uint8Array(parts.slice(KEY_LENGTH));

  // And finally we import the generated bytes into an AES key.
  const key = await crypto.subtle.importKey(
    "raw",
    rawKey,
    { name: "AES-GCM" },
    false,
    ["encrypt", "decrypt"]
  );

  // And return the crypto key and the IV bytes so we can use them elsewhere.
  return { key, iv };
};

export const encryptFile = async (file, password) => {
  // Create a cryptographically-random 16-byte salt, and use that along with the
  // provided password to derive a crypto key and IV.
  const salt = window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
  const { key, iv } = await deriveKey(password, salt);

  // Get the file contents.
  const fileBuffer = await file.arrayBuffer();

  // And encrypt it using the provided key and IV.
  const encrypted = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    fileBuffer
  );

  // Finally, create a new byte array that is the length of the encrypted file
  // plus the length of the salt. We'll prepend the salt to the ciphertext so
  // that it is self-contained.
  const ciphertext = new Uint8Array(encrypted.byteLength + salt.length);
  ciphertext.set(salt, 0);
  ciphertext.set(new Uint8Array(encrypted), salt.length);

  return ciphertext;
};

export const decryptFile = async (file, password) => {
  const fileBuffer = await file.arrayBuffer();

  // Files that we encrypt begin with the salt. Salts aren't sensitive, so this
  // is way easier than asking users to share the password *AND* the salt.
  const salt = fileBuffer.slice(0, SALT_LENGTH);

  // The rest of the file is the encrypted content.
  const encrypted = fileBuffer.slice(16);

  // Now we can derive the key and IV.
  const { key, iv } = await deriveKey(password, salt);

  // Decrypt it!
  const plain = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv },
    key,
    encrypted
  );

  return plain;
};
